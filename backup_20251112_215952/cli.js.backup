#!/usr/bin/env node
// FILENAME: src/cli.js
// Fluxus CLI v4.3 - ENTERPRISE GRADE (Enhanced with Standard Library)

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Core components - verified from tree structure
import { GraphParser } from './core/parser.js';
import { Compiler } from './core/compiler.js';
import { RuntimeEngine } from './core/engine.js';
import { FluxusREPL } from './repl.js';
import { FluxusPackageManager } from './package-manager.js';

// New CLI Commands System
import { COMMAND_REGISTRY } from './cli/commands/index.js';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

class FluxusCLI {
    constructor() {
        this.version = '4.3.0';
        this.build = 'enterprise-mature';
        this.commandRegistry = new Map();
        this.setupCommandRegistry();
    }

    setupCommandRegistry() {
        // Register new command system alongside existing handlers
        for (const [command, CommandClass] of Object.entries(COMMAND_REGISTRY)) {
            this.commandRegistry.set(command, new CommandClass(this));
        }
    }

    async execute() {
        const args = process.argv.slice(2);
        const command = args[0];
        const filename = args[1];
        const options = args.slice(2);

        try {
            await this.dispatchCommand(command, filename, options);
        } catch (error) {
            this.handleFatalError(error);
        }
    }

    async dispatchCommand(command, filename, options) {
        // Try new command system first, fall back to existing handlers
        if (this.commandRegistry.has(command)) {
            const commandInstance = this.commandRegistry.get(command);
            return await commandInstance.execute([filename, ...options]);
        }

        const commandHandlers = {
            'run': () => this.handleRun(filename, options),
            'compile': () => this.handleCompile(filename, options),
            'parse': () => this.handleParse(filename, options),
            'repl': () => this.handleRepl(options),
            'tutorial': () => this.handleTutorial(),
            'dashboard': () => this.handleDashboard(),
            'profile': () => this.handleProfile(filename, options),
            'test': () => this.handleTest(options),
            'libraries': () => this.handleLibraries(filename, options),
            'packages': () => this.handlePackages(filename, options),
            'doctor': () => this.handleDoctor(),
            'benchmark': () => this.handleBenchmark(),
            'version': () => this.handleVersion(),
            'help': () => this.handleHelp(),
            '--help': () => this.handleHelp(),
            '-h': () => this.handleHelp(),
            '': () => this.handleHelp()
        };

        const handler = commandHandlers[command] || this.handleHelp;
        await handler.call(this);
    }

    // üöÄ EXECUTION COMMANDS
    async handleRun(filename, options) {
        if (!filename) {
            this.showUsageError('run <file.flux>');
            return;
        }

        this.showBanner('EXECUTION');
        const source = this.loadSourceFile(filename);
        
        const engine = new RuntimeEngine({
            debugMode: options.includes('--debug'),
            quietMode: options.includes('--quiet')
        });

        const parser = new GraphParser();
        const ast = parser.parse(source);
        
        const compiler = new Compiler();
        const compiledAst = compiler.compile(ast);

        console.log(`üìÅ File: ${filename}`);
        console.log(`üìä AST: ${ast.nodes?.length || 0} nodes`);
        
        await engine.start(ast);
    }

    async handleCompile(filename, options) {
        if (!filename) {
            this.showUsageError('compile <file.flux>');
            return;
        }

        this.showBanner('COMPILATION');
        const source = this.loadSourceFile(filename);
        
        const parser = new GraphParser();
        const ast = parser.parse(source);
        
        const compiler = new Compiler();
        const compiled = compiler.compile(ast);

        console.log('üì¶ Compiled Program:');
        console.log(JSON.stringify(compiled, null, 2));
        
        if (options.includes('--output')) {
            const runtimeCode = compiler.generateRuntimeCode(compiled);
            console.log('\nüîß Generated Runtime Code:');
            console.log(runtimeCode);
        }
    }

    async handleParse(filename, options) {
        if (!filename) {
            this.showUsageError('parse <file.flux>');
            return;
        }

        this.showBanner('PARSING');
        const source = this.loadSourceFile(filename);
        
        const parser = new GraphParser();
        const ast = parser.parse(source);

        console.log('üìñ AST Structure:');
        console.log(JSON.stringify(ast, null, 2));
    }

    async handleRepl(options) {
        this.showBanner('INTERACTIVE REPL');
        const repl = new FluxusREPL({
            debugMode: options.includes('--debug')
        });
        await repl.start();
    }

    async handleTutorial() {
        this.showBanner('TUTORIAL');
        console.log(`
üìö Fluxus Tutorial
==================

1. BASIC STREAMS:
   ~ "Hello" | print                    # One-off stream
   ~? "live_data" | print               # Live stream

2. TRANSFORMATIONS:
   ~ "hello" | to_upper | print         # HELLO
   ~ 5 | add(3) | print                 # 8

3. TIDAL POOLS (State):
   let counter = <|> 0                  # Create pool
   ~? "click" | map { counter -> add(1) } | to_pool(counter)
   counter -> print                     # Subscribe to changes

4. LIBRARIES:
   import math
   ~ 3.14 | sin | print

Run examples: fluxus run examples/hello.flux
        `);
    }

    async handleDashboard() {
        this.showBanner('DASHBOARD');
        const engine = new RuntimeEngine();
        console.log(`
üìä Fluxus Dashboard
===================

Performance Metrics:
${JSON.stringify(engine.getPerformanceMetrics(), null, 2)}

Run 'fluxus profile examples/arithmetic.flux' for detailed analysis
        `);
    }

    async handleProfile(filename, options) {
        if (!filename) {
            this.showUsageError('profile <file.flux>');
            return;
        }

        this.showBanner('PROFILING');
        const source = this.loadSourceFile(filename);
        
        const parser = new GraphParser();
        const ast = parser.parse(source);
        
        const compiler = new Compiler();
        const compiled = compiler.compile(ast);
        
        const engine = new RuntimeEngine();
        
        console.log(`üìä Profiling: ${filename}`);
        
        const startTime = Date.now();
        const startMemory = process.memoryUsage().heapUsed;
        
        await engine.start(ast);
        
        const endTime = Date.now();
        const endMemory = process.memoryUsage().heapUsed;
        
        console.log('\nüìà Performance Report:');
        console.log(`   Execution Time: ${(endTime - startTime).toFixed(2)}ms`);
        console.log(`   Memory Used: ${((endMemory - startMemory) / 1024 / 1024).toFixed(2)}MB`);
        console.log(`   Operations: ${engine.performance.operations}`);
        console.log(`   Warnings: ${compiled.warnings.length}`);
    }

    // üß™ TESTING COMMAND (Enhanced with new test system)
    async handleTest(options) {
        this.showBanner('TEST SUITE');
        console.log('üöÄ Running Fluxus Language Test Suite...\n');
        
        try {
            // Import and run the test runner
            const { runAllTests } = await import('../test-run.js');
            await runAllTests();
        } catch (error) {
            console.error('‚ùå Test suite failed:', error.message);
            process.exit(1);
        }
    }

    // üìö LIBRARY MANAGEMENT (Enhanced with Standard Library)
    async handleLibraries(subcommand, options) {
        this.showBanner('LIBRARY MANAGEMENT');

        switch (subcommand) {
            case 'list':
                console.log('üìö Available Standard Libraries:');
                const compiler = new Compiler();
                const catalog = compiler.getOperatorCatalog();
                
                const libraries = ['core', 'math', 'string', 'collections', 'time', 'reactive', 'network', 'sensors'];
                libraries.forEach(lib => {
                    const libOps = Object.values(catalog).filter(op => op.library === lib).length;
                    console.log(`   üì¶ ${lib} (${libOps} operators)`);
                });
                break;

            case 'operators':
                console.log('üîß Available Operators (Standard Library):');
                const comp = new Compiler();
                const opCatalog = comp.getOperatorCatalog();
                const operatorCount = Object.keys(opCatalog).length;
                console.log(`   Total Operators: ${operatorCount}`);
                
                const categories = {
                    'Core': ['add', 'subtract', 'multiply', 'divide', 'print', 'to_pool'],
                    'Math': ['sin', 'cos', 'tan', 'sqrt', 'pow', 'log'],
                    'String': ['trim', 'to_upper', 'to_lower', 'concat', 'capitalize'],
                    'Collections': ['map', 'reduce', 'filter', 'length', 'keys'],
                    'Time': ['now', 'delay', 'format_time', 'timestamp'],
                    'Reactive': ['combine_latest', 'ui_render']
                };
                
                Object.entries(categories).forEach(([category, ops]) => {
                    console.log(`\n   ${category}:`);
                    console.log(`   ${ops.join(', ')}`);
                });
                break;

            default:
                console.log('üìö Library Commands:');
                console.log('  fluxus libraries list          List available libraries');
                console.log('  fluxus libraries operators     Show operators by category');
        }
    }

    // üì¶ PACKAGE MANAGEMENT
    async handlePackages(subcommand, options) {
        const pm = new FluxusPackageManager();
        this.showBanner('PACKAGE MANAGEMENT');

        switch (subcommand) {
            case 'install':
                if (!options[0]) {
                    console.error('‚ùå Usage: fluxus packages install <package-name>');
                    return;
                }
                console.log(`üì¶ Installing: ${options[0]}`);
                // pm.install(options[0]);
                break;

            case 'list':
                console.log('üì¶ Installed Packages:');
                console.log('   http');
                console.log('   sensors-mock');
                console.log('   sensors-real');
                break;

            default:
                console.log('üì¶ Package Commands:');
                console.log('  fluxus packages install <pkg>    Install a package');
                console.log('  fluxus packages list            List installed packages');
        }
    }

    // ü©∫ SYSTEM DIAGNOSTICS
    async handleDoctor() {
        this.showBanner('SYSTEM DIAGNOSTICS');
        
        const checks = [
            { name: 'Core Parser', check: () => new GraphParser() },
            { name: 'Compiler', check: () => new Compiler() },
            { name: 'Runtime Engine', check: () => new RuntimeEngine() },
            { name: 'Package Manager', check: () => new FluxusPackageManager() },
            { name: 'REPL System', check: () => new FluxusREPL() },
            { name: 'Standard Library', check: () => new Compiler().getOperatorCatalog() }
        ];

        let allPassed = true;
        
        for (const check of checks) {
            try {
                check.check();
                console.log(`‚úÖ ${check.name}: OK`);
            } catch (error) {
                console.log(`‚ùå ${check.name}: FAILED - ${error.message}`);
                allPassed = false;
            }
        }

        console.log(allPassed ? '\nüíö All systems operational!' : '\nüíî Some systems need attention.');
    }

    // üèÉ PERFORMANCE BENCHMARK
    async handleBenchmark() {
        this.showBanner('PERFORMANCE BENCHMARK');
        
        const examples = ['examples/arithmetic.flux', 'examples/hello.flux', 'examples/strings.flux'];
        
        for (const example of examples) {
            try {
                const source = this.loadSourceFile(example);
                const parser = new GraphParser();
                const ast = parser.parse(source);
                const compiler = new Compiler();
                const compiledAst = compiler.compile(ast);
                const engine = new RuntimeEngine({ quietMode: true });
                
                const startTime = Date.now();
                await engine.start(ast);
                const executionTime = Date.now() - startTime;

                console.log(`‚è±Ô∏è  ${example}: ${executionTime}ms`);
            } catch (error) {
                console.log(`‚ùå ${example}: ERROR - ${error.message}`);
            }
        }
    }

    // ‚ÑπÔ∏è INFORMATIONAL COMMANDS
    handleVersion() {
        console.log(`üåä Fluxus Language v${this.version}`);
        console.log(`   Build: ${this.build}`);
        console.log(`   Status: Mature Standard`);
        console.log(`   Standard Library: Integrated`);
    }

    handleHelp() {
        this.showBanner('COMMAND REFERENCE');
        
        console.log('üöÄ EXECUTION:');
        console.log('  fluxus run <file.flux>       Execute a Fluxus program');
        console.log('  fluxus compile <file.flux>   Compile to IR');
        console.log('  fluxus parse <file.flux>     Parse and show AST');
        console.log('  fluxus repl                  Start interactive REPL');
        console.log('  fluxus profile <file.flux>   Profile performance');
        console.log('');
        
        console.log('üìö DEVELOPMENT:');
        console.log('  fluxus tutorial              Show language tutorial');
        console.log('  fluxus dashboard             Show runtime dashboard');
        console.log('  fluxus test                  Run full test suite');
        console.log('  fluxus libraries list        List available libraries');
        console.log('  fluxus libraries operators   Show operators by category');
        console.log('  fluxus packages list         List installed packages');
        console.log('');
        
        console.log('üß™ TESTING & QUALITY:');
        console.log('  fluxus benchmark            Performance benchmarks');
        console.log('  fluxus doctor               System diagnostics');
        console.log('');
        
        console.log('‚ÑπÔ∏è INFORMATION:');
        console.log('  fluxus version              Show version information');
        console.log('  fluxus help                 This help message');
        console.log('');
        
        console.log('üí° Examples:');
        console.log('  fluxus run examples/hello.flux');
        console.log('  fluxus test');
        console.log('  fluxus repl');
        console.log('  fluxus tutorial');
        console.log('  fluxus doctor');
    }

    // üéØ UTILITY METHODS
    loadSourceFile(filePath) {
        try {
            return fs.readFileSync(filePath, 'utf-8');
        } catch (error) {
            throw new Error(`Could not read file: ${filePath}`);
        }
    }

    showBanner(section) {
        console.log(`\nüåä FLUXUS v${this.version} - ${section}`);
        console.log('‚ïê'.repeat(50));
    }

    showUsageError(usage) {
        console.error(`‚ùå Usage: fluxus ${usage}`);
    }

    handleFatalError(error) {
        console.error('üí• Fluxus CLI Fatal Error:');
        console.error(error);
        process.exit(1);
    }
}

// üéØ MAIN FUNCTION - This is what bin/fluxus.js expects
export function main() {
    const cli = new FluxusCLI();
    return cli.execute();
}

// Export the class for programmatic use
export { FluxusCLI };

// Auto-execute if this file is run directly
if (import.meta.url === `file://${process.argv[1]}`) {
    main();
}
