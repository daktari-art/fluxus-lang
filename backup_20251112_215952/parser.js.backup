// FILENAME: src/core/parser.js
// Fluxus Language Graph Parser v7.1 - STANDARD LIBRARY INTEGRATED

/**
 * Production-grade parser for Fluxus Reactive Stream Language
 * Enhanced with Standard Library awareness
 */

const generateUUID = () => `node_${Math.random().toString(36).substring(2, 9)}_${Date.now()}`;

export class GraphParser {
    constructor() {
        this.connectionTypes = {
            '|': 'PIPE_FLOW',
            '->': 'POOL_READ_FLOW',
            '<-': 'POOL_WRITE_FLOW'
        };

        // Enhanced operator classification with Standard Library awareness
        this.operatorCategories = {
            'SOURCE': ['~', '~?'],
            'SINK': ['print', 'to_pool', 'ui_render', 'write_file'],
            'TRANSFORM': ['add', 'subtract', 'multiply', 'divide', 'trim', 'to_upper', 'to_lower', 'concat'],
            'MATH': ['sin', 'cos', 'tan', 'sqrt', 'pow', 'log', 'exp', 'abs', 'floor', 'ceil', 'round', 'max', 'min', 'random'],
            'STRING': ['capitalize', 'reverse', 'replace', 'substring', 'contains', 'starts_with', 'ends_with', 'split_lines', 'length', 'repeat'],
            'COLLECTION': ['map', 'reduce', 'filter', 'split', 'length', 'get', 'set', 'keys', 'values'],
            'COMBINATION': ['combine_latest', 'merge', 'concat'],
            'CONTROL': ['split', 'debounce', 'throttle', 'delay'],
            'LENS': ['map', 'reduce', 'filter', 'split']
        };

        // Standard Library imports mapping
        this.standardLibraries = {
            'math': ['sin', 'cos', 'tan', 'sqrt', 'pow', 'log', 'exp', 'abs', 'floor', 'ceil', 'round', 'max', 'min', 'random', 'mean', 'median', 'sum'],
            'string': ['capitalize', 'reverse', 'replace', 'substring', 'contains', 'starts_with', 'ends_with', 'split_lines', 'pad_left', 'pad_right', 'length', 'match', 'test', 'repeat'],
            'time': ['now', 'performance_now', 'timestamp', 'add_milliseconds', 'add_seconds', 'add_minutes', 'add_hours', 'format_time', 'to_iso_string'],
            'collections': ['length', 'get', 'set', 'keys', 'values', 'merge', 'slice', 'first', 'last', 'find'],
            'types': ['type_of', 'is_array', 'is_object', 'is_string', 'is_number', 'is_boolean', 'cast_string', 'cast_number', 'cast_boolean']
        };

        this.debugMode = process.env.FLUXUS_PARSER_DEBUG === 'true';
    }

    /**
     * Main parsing entry point - converts Fluxus source to AST
     * Enhanced with Standard Library awareness
     */
    parse(sourceCode) {
        const ast = {
            nodes: [],
            connections: [],
            pools: {},
            imports: [],
            functions: {},
            liveStreams: [],
            finiteStreams: [],
            metadata: {
                sourceLines: 0,
                parsedAt: new Date().toISOString(),
                version: '4.3.0',
                standardLibrary: {
                    usedLibraries: new Set(),
                    operatorCount: 0
                }
            }
        };

        const lines = this.preprocessSource(sourceCode);
        ast.metadata.sourceLines = lines.length;

        let currentPipeline = null;
        let pipelineStack = [];

        for (const { line, lineNum } of lines) {
            try {
                // Handle imports FIRST - critical for library loading
                if (this.isImport(line)) {
                    this.parseImport(line, lineNum, ast);
                    continue;
                }

                // Handle pool declarations
                if (this.isPoolDeclaration(line)) {
                    this.parsePoolDeclaration(line, lineNum, ast);
                    continue;
                }

                // Handle function definitions
                if (this.isFunctionDefinition(line)) {
                    this.parseFunctionDefinition(line, lineNum, ast);
                    continue;
                }

                // Handle subscriptions
                if (this.isSubscription(line)) {
                    this.parseSubscription(line, lineNum, ast);
                    continue;
                }

                // Handle stream pipelines with Standard Library awareness
                if (this.isStreamPipeline(line)) {
                    currentPipeline = this.parseStreamPipeline(line, lineNum, ast, currentPipeline);
                    pipelineStack.push(currentPipeline);
                } else if (currentPipeline && this.isPipelineContinuation(line)) {
                    // Continue existing pipeline
                    currentPipeline = this.extendPipeline(line, lineNum, ast, currentPipeline);
                } else if (this.isPipelineTermination(line)) {
                    // Pipeline termination
                    currentPipeline = pipelineStack.length > 0 ? pipelineStack.pop() : null;
                } else {
                    // Reset pipeline if we hit a non-pipeline line
                    currentPipeline = null;
                    pipelineStack = [];
                }
            } catch (error) {
                this.logParseError(lineNum, line, error.message);
                // Continue parsing despite errors
            }
        }

        this.validateAST(ast);
        this.analyzeStandardLibraryUsage(ast);
        return ast;
    }

    /**
     * Enhanced import parsing with Standard Library awareness
     */
    parseImport(line, lineNum, ast) {
        if (line.startsWith('FLOW')) {
            const flowMatch = line.match(/FLOW\s+([a-zA-Z_][a-zA-Z0-9_]*)/);
            if (flowMatch) {
                ast.imports.push(flowMatch[1]);
                this.logParseInfo(lineNum, `Imported flow: ${flowMatch[1]}`);
            } else {
                this.logParseWarning(lineNum, `Malformed FLOW statement: ${line}`);
            }
        } else if (line.startsWith('import ')) {
            // Handle standard import statements: import math, import string, import time
            const importMatch = line.match(/import\s+([a-zA-Z_][a-zA-Z0-9_]*)/);
            if (importMatch) {
                const libName = importMatch[1];
                ast.imports.push(libName);
                
                // Track Standard Library usage
                if (this.standardLibraries[libName]) {
                    ast.metadata.standardLibrary.usedLibraries.add(libName);
                }
                
                this.logParseInfo(lineNum, `Imported library: ${libName}`);
            } else {
                this.logParseWarning(lineNum, `Malformed import statement: ${line}`);
            }
        } else if (line.startsWith('IMPORT')) {
            const importMatch = line.match(/IMPORT\s+([a-zA-Z_][a-zA-Z0-9_]*)\s+FROM\s+"([^"]+)"/);
            if (importMatch) {
                ast.imports.push({
                    alias: importMatch[1],
                    path: importMatch[2],
                    type: 'MODULE'
                });
                this.logParseInfo(lineNum, `Imported module: ${importMatch[1]} from ${importMatch[2]}`);
            }
        } else if (line.startsWith('FROM')) {
            const fromMatch = line.match(/FROM\s+"([^"]+)"\s+IMPORT\s+([a-zA-Z_][a-zA-Z0-9_]*)/);
            if (fromMatch) {
                ast.imports.push({
                    alias: fromMatch[2],
                    path: fromMatch[1],
                    type: 'MODULE'
                });
            }
        }
    }

    /**
     * Enhanced operator parsing with Standard Library categorization
     */
    parseOperator(part, lineNum, pipelineId) {
        let name = part;
        let args = [];
        let type = 'FUNCTION_OPERATOR';
        let category = 'TRANSFORM';

        // Enhanced lens operator detection
        const lensOperators = ['map', 'reduce', 'filter', 'split', 'compose_lenses', 'conditional_lens', 'transform_paths'];
        const lensPattern = /^(\w+)\s*\{([^}]*)\}\s*$/;
        const lensMatch = part.match(lensPattern);

        if (lensMatch && lensOperators.includes(lensMatch[1])) {
            name = lensMatch[1].trim();
            const lensContent = lensMatch[2].trim();
            args = [lensContent];
            type = 'LENS_OPERATOR';
            category = 'LENS';
        }
        else if (part.includes('(') && part.includes(')')) {
            const openParen = part.indexOf('(');
            const closeParen = part.lastIndexOf(')');

            if (openParen < closeParen) {
                name = part.substring(0, openParen).trim();
                const argString = part.substring(openParen + 1, closeParen).trim();

                if (argString) {
                    args = this.parseArgs(argString);
                }
            }

            // Enhanced operator classification with Standard Library awareness
            category = this.classifyOperatorWithLibrary(name);
        }
        else if (/\w+\s*\(/.test(part)) {
            const match = part.match(/(\w+)\s*\((.*)\)/);
            if (match) {
                name = match[1].trim();
                const argString = match[2].trim();
                if (argString) {
                    args = this.parseArgs(argString);
                }
                category = this.classifyOperatorWithLibrary(name);
            }
        }
        else if (part === 'TRUE_FLOW' || part === 'FALSE_FLOW') {
            name = part;
            type = 'FLOW_BRANCH';
            category = 'CONTROL';
            args = [];
        }
        else {
            name = part.trim();
            category = this.classifyOperatorWithLibrary(name);
        }

        return {
            id: generateUUID(),
            pipelineId: pipelineId,
            type: type,
            name: name,
            args: args,
            value: part,
            line: lineNum,
            isTerminal: false,
            category: category,
            library: this.detectOperatorLibrary(name)
        };
    }

    /**
     * Enhanced operator classification with Standard Library mapping
     */
    classifyOperatorWithLibrary(operatorName) {
        for (const [category, operators] of Object.entries(this.operatorCategories)) {
            if (operators.includes(operatorName)) {
                return category;
            }
        }
        
        // Check if it's a Standard Library operator
        for (const [lib, operators] of Object.entries(this.standardLibraries)) {
            if (operators.includes(operatorName)) {
                return lib.toUpperCase();
            }
        }
        
        return 'TRANSFORM'; // Default category
    }

    /**
     * Detect which Standard Library an operator belongs to
     */
    detectOperatorLibrary(operatorName) {
        for (const [lib, operators] of Object.entries(this.standardLibraries)) {
            if (operators.includes(operatorName)) {
                return lib;
            }
        }
        return 'core';
    }

    /**
     * Analyze Standard Library usage in the parsed AST
     */
    analyzeStandardLibraryUsage(ast) {
        const usedLibraries = new Set();
        let operatorCount = 0;

        // Analyze nodes for Standard Library operators
        ast.nodes.forEach(node => {
            if (node.type === 'FUNCTION_OPERATOR' || node.type === 'LENS_OPERATOR') {
                operatorCount++;
                const library = this.detectOperatorLibrary(node.name);
                if (library !== 'core') {
                    usedLibraries.add(library);
                }
            }
        });

        // Update metadata
        ast.metadata.standardLibrary.usedLibraries = new Set([...ast.metadata.standardLibrary.usedLibraries, ...usedLibraries]);
        ast.metadata.standardLibrary.operatorCount = operatorCount;

        if (this.debugMode && usedLibraries.size > 0) {
            console.log(`ðŸ“š Standard Library Analysis:`);
            console.log(`   Used libraries: ${Array.from(usedLibraries).join(', ')}`);
            console.log(`   Total operators: ${operatorCount}`);
        }
    }

    // ==================== EXISTING METHODS (preserved for compatibility) ====================

    preprocessSource(sourceCode) {
        const lines = sourceCode.split('\n');
        const processed = [];
        let inMultilineComment = false;

        for (let i = 0; i < lines.length; i++) {
            let line = lines[i].trim();

            // Skip empty lines
            if (!line) continue;

            // Handle multiline comments
            if (inMultilineComment) {
                if (line.includes('*/')) {
                    inMultilineComment = false;
                    line = line.substring(line.indexOf('*/') + 2).trim();
                } else {
                    continue; // Skip entire line if in multiline comment
                }
            }

            // Check for multiline comment start
            if (line.includes('/*')) {
                inMultilineComment = true;
                line = line.substring(0, line.indexOf('/*')).trim();
                if (!line) continue;
            }

            // Remove single-line comments
            const commentIndex = line.indexOf('#');
            if (commentIndex !== -1) {
                line = line.substring(0, commentIndex).trim();
            }

            // Remove JavaScript-style comments for compatibility
            const jsCommentIndex = line.indexOf('//');
            if (jsCommentIndex !== -1) {
                line = line.substring(0, jsCommentIndex).trim();
            }

            if (line) {
                processed.push({ line, lineNum: i + 1 });
            }
        }

        if (this.debugMode) {
            console.log(`ðŸ“ Preprocessed ${processed.length}/${lines.length} lines`);
        }

        return processed;
    }

    isImport(line) {
        return line.startsWith('FLOW') || line.startsWith('IMPORT') || line.startsWith('FROM') || line.startsWith('import ');
    }

    isPoolDeclaration(line) {
        return line.includes('<|>') && line.startsWith('let ');
    }

    parsePoolDeclaration(line, lineNum, ast) {
        const match = line.match(/let\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*=\s*<\|>\s*(.*)/);
        if (match) {
            const poolName = match[1];
            let initialValue = match[2].trim() || 'null';

            // Validate pool name
            if (!this.isValidIdentifier(poolName)) {
                throw new Error(`Invalid pool name: ${poolName}`);
            }

            ast.pools[poolName] = {
                id: generateUUID(),
                name: poolName,
                initial: initialValue,
                line: lineNum,
                value: null,
                type: this.inferType(initialValue)
            };

            this.logParseInfo(lineNum, `Declared pool: ${poolName} = ${initialValue}`);
        } else {
            throw new Error(`Malformed pool declaration: ${line}`);
        }
    }

    isFunctionDefinition(line) {
        return line.startsWith('FUNC ') || line.startsWith('function ');
    }

    parseFunctionDefinition(line, lineNum, ast) {
        const funcMatch = line.match(/(?:FUNC|function)\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\(([^)]*)\)\s*:/);
        if (funcMatch) {
            const funcName = funcMatch[1];
            const params = funcMatch[2].split(',').map(p => p.trim()).filter(p => p);

            ast.functions[funcName] = {
                id: generateUUID(),
                name: funcName,
                parameters: params,
                line: lineNum,
                body: [] // Will be populated with subsequent lines
            };

            this.logParseInfo(lineNum, `Defined function: ${funcName}(${params.join(', ')})`);
        }
    }

    isSubscription(line) {
        return line.includes('->') &&
               !line.startsWith('~') &&
               !line.startsWith('|') &&
               !line.startsWith('TRUE_FLOW') &&
               !line.startsWith('FALSE_FLOW') &&
               !this.isPoolDeclaration(line);
    }

    parseSubscription(line, lineNum, ast) {
        const parts = line.split('->').map(p => p.trim());
        if (parts.length !== 2) {
            throw new Error(`Invalid subscription format. Expected: pool -> pipeline`);
        }

        const poolName = parts[0];

        if (!ast.pools[poolName]) {
            this.logParseWarning(lineNum, `Subscription uses undeclared pool: ${poolName}`);
        }

        const subscriptionFlow = parts[1];
        const pipelineId = generateUUID();

        const poolReadNode = {
            id: generateUUID(),
            pipelineId: pipelineId,
            type: 'POOL_READ',
            name: 'POOL_READ',
            value: poolName,
            line: lineNum,
            isTerminal: false,
            category: 'SOURCE'
        };
        ast.nodes.push(poolReadNode);

        let previousNodeId = poolReadNode.id;

        const flowParts = this.splitPipeline(subscriptionFlow);

        for (const part of flowParts) {
            const operatorNode = this.parseOperator(part, lineNum, pipelineId);
            ast.nodes.push(operatorNode);

            ast.connections.push({
                id: generateUUID(),
                from: previousNodeId,
                to: operatorNode.id,
                type: this.connectionTypes['|'],
                line: lineNum
            });

            previousNodeId = operatorNode.id;

            if (this.isTerminalOperator(operatorNode.name)) {
                operatorNode.isTerminal = true;
            }
        }

        ast.connections.push({
            id: generateUUID(),
            from: poolReadNode.id,
            to: previousNodeId,
            type: this.connectionTypes['->'],
            line: lineNum
        });

        this.logParseInfo(lineNum, `Created subscription: ${poolName} -> ${subscriptionFlow}`);
    }

    isStreamPipeline(line) {
        return line.startsWith('~') ||
               (line.includes('|') && !this.isSubscription(line)) ||
               line.startsWith('TRUE_FLOW') ||
               line.startsWith('FALSE_FLOW');
    }

    isPipelineContinuation(line) {
        return line.startsWith('|') ||
               line.startsWith('TRUE_FLOW') ||
               line.startsWith('FALSE_FLOW');
    }

    isPipelineTermination(line) {
        return line === 'END' || line.startsWith('END_FLOW');
    }

    parseStreamPipeline(line, lineNum, ast, currentPipeline) {
        const pipelineId = currentPipeline?.id || generateUUID();
        let previousNodeId = currentPipeline?.lastNodeId || null;

        const parts = this.splitPipeline(line);

        for (let i = 0; i < parts.length; i++) {
            const part = parts[i];

            if (part.startsWith('~')) {
                const isLive = part.startsWith('~?');
                const valuePart = part.substring(isLive ? 2 : 1).trim();

                const sourceNode = {
                    id: generateUUID(),
                    pipelineId: pipelineId,
                    type: isLive ? 'STREAM_SOURCE_LIVE' : 'STREAM_SOURCE_FINITE',
                    name: isLive ? 'LIVE_SOURCE' : 'FINITE_SOURCE',
                    value: valuePart,
                    line: lineNum,
                    isTerminal: false,
                    category: 'SOURCE'
                };

                ast.nodes.push(sourceNode);

                if (isLive) {
                    ast.liveStreams.push(sourceNode.id);
                } else {
                    ast.finiteStreams.push(sourceNode.id);
                }

                previousNodeId = sourceNode.id;

            } else if (part.startsWith('TRUE_FLOW') || part.startsWith('FALSE_FLOW')) {
                const type = part.startsWith('TRUE_FLOW') ? 'TRUE_FLOW' : 'FALSE_FLOW';

                const flowNode = {
                    id: generateUUID(),
                    pipelineId: pipelineId,
                    type: type,
                    name: type,
                    value: null,
                    line: lineNum,
                    isTerminal: false,
                    category: 'CONTROL'
                };
                ast.nodes.push(flowNode);

                if (previousNodeId) {
                    ast.connections.push({
                        id: generateUUID(),
                        from: previousNodeId,
                        to: flowNode.id,
                        type: this.connectionTypes['|'],
                        line: lineNum
                    });
                }

                previousNodeId = flowNode.id;

            } else if (part.length > 0) {
                const operatorNode = this.parseOperator(part, lineNum, pipelineId);
                ast.nodes.push(operatorNode);

                if (previousNodeId) {
                    ast.connections.push({
                        id: generateUUID(),
                        from: previousNodeId,
                        to: operatorNode.id,
                        type: this.connectionTypes['|'],
                        line: lineNum
                    });
                }

                previousNodeId = operatorNode.id;

                if (this.isTerminalOperator(operatorNode.name)) {
                    operatorNode.isTerminal = true;
                }
            }
        }

        return {
            id: pipelineId,
            lastNodeId: previousNodeId,
            lineNum: lineNum
        };
    }

    extendPipeline(line, lineNum, ast, currentPipeline) {
        return this.parseStreamPipeline(line, lineNum, ast, currentPipeline);
    }

    parseArgs(argString) {
        // Handle empty argument list
        if (!argString.trim()) return [];

        const args = [];
        let current = '';
        let braceDepth = 0;
        let bracketDepth = 0;
        let parenDepth = 0;
        let quote = null;
        let escapeNext = false;

        for (let i = 0; i < argString.length; i++) {
            const char = argString[i];

            if (escapeNext) {
                current += char;
                escapeNext = false;
                continue;
            }

            if (char === '\\') {
                escapeNext = true;
                continue;
            }

            if (char === '"' || char === "'") {
                if (quote === char) {
                    quote = null;
                } else if (quote === null) {
                    quote = char;
                }
                current += char;
                continue;
            }

            if (quote === null) {
                if (char === '{') braceDepth++;
                if (char === '}') braceDepth--;
                if (char === '[') bracketDepth++;
                if (char === ']') bracketDepth--;
                if (char === '(') parenDepth++;
                if (char === ')') parenDepth--;

                if (char === ',' && braceDepth === 0 && bracketDepth === 0 && parenDepth === 0) {
                    if (current.trim()) {
                        args.push(this.cleanArgument(current.trim()));
                    }
                    current = '';
                    continue;
                }
            }

            current += char;
        }

        if (current.trim()) {
            args.push(this.cleanArgument(current.trim()));
        }

        return args;
    }

    cleanArgument(arg) {
        // Remove surrounding quotes if present
        if ((arg.startsWith("'") && arg.endsWith("'")) ||
            (arg.startsWith('"') && arg.endsWith('"'))) {
            return arg.slice(1, -1);
        }
        return arg;
    }

    splitPipeline(line) {
        if (line.includes('<|>')) {
            return [line];
        }

        const parts = [];
        let current = '';
        let braceDepth = 0;
        let bracketDepth = 0;
        let parenDepth = 0;
        let quote = null;
        let escapeNext = false;

        for (let i = 0; i < line.length; i++) {
            const char = line[i];

            if (escapeNext) {
                current += char;
                escapeNext = false;
                continue;
            }

            if (char === '\\') {
                escapeNext = true;
                continue;
            }

            if (char === '"' || char === "'") {
                if (quote === char) {
                    quote = null;
                } else if (quote === null) {
                    quote = char;
                }
            }

            if (quote === null) {
                if (char === '{') braceDepth++;
                if (char === '}') braceDepth--;
                if (char === '[') bracketDepth++;
                if (char === ']') bracketDepth--;
                if (char === '(') parenDepth++;
                if (char === ')') parenDepth--;
            }

            if (char === '|' && braceDepth === 0 && bracketDepth === 0 && parenDepth === 0 && quote === null) {
                if (current.trim()) {
                    parts.push(current.trim());
                }
                current = '';
            } else {
                current += char;
            }
        }

        if (current.trim()) {
            parts.push(current.trim());
        }

        return parts;
    }

    isTerminalOperator(operatorName) {
        const terminalOps = ['to_pool', 'print', 'ui_render', 'write_file', 'RESULT'];
        return terminalOps.includes(operatorName);
    }

    isValidIdentifier(name) {
        return /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(name);
    }

    inferType(value) {
        if (value === 'null') return 'null';
        if (value === 'true' || value === 'false') return 'boolean';
        if (!isNaN(value) && value.trim() !== '') return 'number';
        if ((value.startsWith("'") && value.endsWith("'")) ||
            (value.startsWith('"') && value.endsWith('"'))) return 'string';
        if (value.startsWith('[') && value.endsWith(']')) return 'array';
        if (value.startsWith('{') && value.endsWith('}')) return 'object';
        return 'any';
    }

    validateAST(ast) {
        const warnings = [];

        // Check for unused pools
        Object.keys(ast.pools).forEach(poolName => {
            const usedInSubscriptions = ast.nodes.some(node =>
                node.type === 'POOL_READ' && node.value === poolName
            );
            if (!usedInSubscriptions) {
                warnings.push(`Pool '${poolName}' is declared but never used`);
            }
        });

        // Check for disconnected nodes
        const connectedNodes = new Set();
        ast.connections.forEach(conn => {
            connectedNodes.add(conn.from);
            connectedNodes.add(conn.to);
        });

        ast.nodes.forEach(node => {
            if (!connectedNodes.has(node.id) && node.type !== 'STREAM_SOURCE_FINITE' && node.type !== 'STREAM_SOURCE_LIVE') {
                warnings.push(`Node '${node.name}' (line ${node.line}) is disconnected from the flow`);
            }
        });

        if (warnings.length > 0 && this.debugMode) {
            console.log('ðŸ” Parser Validation Warnings:');
            warnings.forEach(warning => console.log(`   âš ï¸ ${warning}`));
        }

        return warnings;
    }

    logParseInfo(lineNum, message) {
        if (this.debugMode) {
            console.log(`ðŸ“ [Line ${lineNum}] ${message}`);
        }
    }

    logParseWarning(lineNum, message) {
        console.log(`âš ï¸ [Line ${lineNum}] ${message}`);
    }

    logParseError(lineNum, line, message) {
        console.error(`âŒ [Line ${lineNum}] Parse Error: ${message}`);
        console.error(`   Code: ${line}`);
    }

    // Utility method for debugging
    printASTSummary(ast) {
        console.log('\nðŸ“Š Parser Summary:');
        console.log(`   ðŸ“ Lines processed: ${ast.metadata.sourceLines}`);
        console.log(`   ðŸ“¦ Nodes created: ${ast.nodes.length}`);
        console.log(`   ðŸ”— Connections: ${ast.connections.length}`);
        console.log(`   ðŸŠ Pools: ${Object.keys(ast.pools).length}`);
        console.log(`   ðŸ“š Imports: ${ast.imports.length}`);
        console.log(`   ðŸ”„ Live streams: ${ast.liveStreams.length}`);
        console.log(`   â¹ï¸ Finite streams: ${ast.finiteStreams.length}`);
        console.log(`   ðŸ“– Standard Libraries: ${Array.from(ast.metadata.standardLibrary.usedLibraries).join(', ')}`);
        console.log(`   ðŸ”§ Operators: ${ast.metadata.standardLibrary.operatorCount}`);

        // Node type breakdown
        const nodeTypes = {};
        ast.nodes.forEach(node => {
            nodeTypes[node.type] = (nodeTypes[node.type] || 0) + 1;
        });
        console.log(`   ðŸŽ¯ Node types:`, nodeTypes);
    }
}
